<!-- Only the JavaScript part has been updated - the rest of the HTML remains the same -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
      // Elements
      const resultForm = document.getElementById('resultForm');
      const registrationNumber = document.getElementById('registrationNumber');
      const loading = document.getElementById('loading');
      const resultContainer = document.getElementById('resultContainer');
      const testConnectionBtn = document.getElementById('testConnectionBtn');
      const statusLog = document.getElementById('statusLog');
      const progressBar = document.getElementById('progressBar');
      const progressPercentage = document.getElementById('progressPercentage');
      const currentStatus = document.getElementById('currentStatus');
      const themeToggle = document.getElementById('themeToggle');
      const cursorDot = document.getElementById('cursorDot');
      const contactForm = document.getElementById('contact-form');
      const contactFormStatus = document.getElementById('contact-form-status');
      const downloadLogBtn = document.getElementById('downloadLogBtn');
      const clearLogBtn = document.getElementById('clearLogBtn');
      const semesterResults = document.getElementById('semesterResults');
      const gpaResultCard = document.getElementById('gpaResultCard');
      const studentName = document.getElementById('studentName');
      const studentReg = document.getElementById('studentReg');
      const totalCgpa = document.getElementById('totalCgpa');
      const totalPercentage = document.getElementById('totalPercentage');
      const calculateCgpaBtn = document.getElementById('calculateCgpaBtn');
      const courseDetailsModal = new bootstrap.Modal(document.getElementById('courseDetailsModal'));
      
      // State variables
      let allLogs = [];
      let testInProgress = false;
      let scrapedData = null;
      let processedData = null;
      
      // API endpoints
      const API_ENDPOINTS = {
        scrape: `/api/result-scraper`,
        test: `/api/result-scraper`
      };
      
      // Initialize the application
      function init() {
        initCustomCursor();
        initTheme();
        initContactForm();
        createToastContainer();
        initAddCustomCourseModal();
      }
      
      // Initialize the add custom course modal
      function initAddCustomCourseModal() {
        // Create modal element
        const modalHTML = `
          <div class="modal fade" id="addCourseModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered">
              <div class="modal-content">
                <div class="modal-header">
                  <h5 class="modal-title">Add New Course</h5>
                  <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                  <form id="addCourseForm" class="space-y-4">
                    <input type="hidden" id="customCourseSemester" value="">
                    <div class="row">
                      <div class="col-md-6">
                        <label class="form-label">Course Code</label>
                        <input required placeholder="e.g., CS-101" class="form-control" type="text">
                      </div>
                      <div class="col-md-6">
                        <label class="form-label">Credit Hours</label>
                        <select required class="form-select">
                          <option value="">Select Credit Hours</option>
                          <option value="1">1</option>
                          <option value="2">2</option>
                          <option value="3">3</option>
                          <option value="4">4</option>
                          <option value="5">5</option>
                        </select>
                      </div>
                    </div>
                    <div class="row">
                      <div class="col-12">
                        <label class="form-label">Course Title <span class="text-muted">(Optional)</span></label>
                        <input placeholder="e.g., Introduction to Computer Science" class="form-control" type="text">
                      </div>
                    </div>
                    <div class="row">
                      <div class="col-12">
                        <label class="form-label">Obtained Marks</label>
                        <input required min="0" step="0.1" class="form-control" type="number">
                      </div>
                    </div>
                    <div class="row mt-3">
                      <div class="col-12 d-flex justify-content-end gap-2">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="submit" class="btn btn-primary">Add Course</button>
                      </div>
                    </div>
                  </form>
                </div>
              </div>
            </div>
          </div>
        `;
        
        // Add modal to body
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        // Add event listener for form submission
        document.getElementById('addCourseForm').addEventListener('submit', function(e) {
          e.preventDefault();
          addCustomCourse();
        });
      }
      
      // Add custom course
      function addCustomCourse() {
        const form = document.getElementById('addCourseForm');
        const semesterName = document.getElementById('customCourseSemester').value;
        const formData = new FormData(form);
        
        const courseCode = form.querySelector('input[type="text"]').value;
        const creditHours = parseInt(form.querySelector('select').value);
        const courseTitle = form.querySelectorAll('input[type="text"]')[1].value;
        const marks = parseFloat(form.querySelector('input[type="number"]').value);
        
        if (!courseCode || !creditHours || isNaN(marks) || !semesterName) {
          showToast('Please fill all required fields', 'error');
          return;
        }
        
        // Calculate quality points
        const qualityPoints = calculateQualityPoints(marks, creditHours);
        
        // Determine grade based on marks
        let grade = 'F';
        if (marks >= 85) grade = 'A';
        else if (marks >= 80) grade = 'A-';
        else if (marks >= 75) grade = 'B+';
        else if (marks >= 70) grade = 'B';
        else if (marks >= 65) grade = 'B-';
        else if (marks >= 60) grade = 'C+';
        else if (marks >= 55) grade = 'C';
        else if (marks >= 50) grade = 'C-';
        else if (marks >= 45) grade = 'D';
        
        const courseData = {
          code: courseCode,
          title: courseTitle || courseCode,
          creditHours: creditHours,
          marks: marks,
          qualityPoints: qualityPoints,
          grade: grade,
          originalSemester: semesterName,
          semesterName: semesterName,
          semesterSortKey: processedData.semesters[semesterName]?.sortKey || '9999-9',
          teacher: 'Custom',
          mid: '0',
          assignment: '0',
          final: marks.toString(),
          practical: '0',
          total: marks.toString(),
          isExtraEnrolled: false,
          isRepeated: false,
          isDeleted: false,
          originalSemesterForRepeated: null,
          isCustom: true
        };
        
        // Add course to semester
        processedData.semesters[semesterName].courses.push(courseData);
        
        // Recalculate CGPA
        const cgpaData = calculateCGPA(processedData);
        
        // Update display
        displayCGPAResults(processedData, cgpaData);
        
        // Close modal and reset form
        bootstrap.Modal.getInstance(document.getElementById('addCourseModal')).hide();
        form.reset();
        
        showToast('Custom course added successfully!', 'success');
        addStatusMessage(`Added custom course: ${courseCode} to ${semesterName}`, 'info');
      }
      
      // Create a custom toast container
      function createToastContainer() {
        const toastContainer = document.createElement('div');
        toastContainer.id = 'toast-container';
        document.body.appendChild(toastContainer);
      }
      
      // Show toast notification
      function showToast(message, type = 'success') {
        const toastContainer = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.innerHTML = `
          <div class="toast-content">
            <i class="toast-icon ${getToastIcon(type)}"></i>
            <span class="toast-message">${message}</span>
          </div>
          <div class="toast-progress"></div>
        `;
        
        toastContainer.appendChild(toast);
        
        // Animate in
        setTimeout(() => {
          toast.classList.add('show');
        }, 10);
        
        // Remove after delay
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300);
        }, 3000);
      }
      
      // Get icon for toast type
      function getToastIcon(type) {
        switch(type) {
          case 'success': return 'fa-solid fa-circle-check';
          case 'error': return 'fa-solid fa-circle-exclamation';
          case 'warning': return 'fa-solid fa-triangle-exclamation';
          case 'info': return 'fa-solid fa-circle-info';
          default: return 'fa-solid fa-circle-info';
        }
      }
      
      // Initialize custom cursor
      function initCustomCursor() {
        document.addEventListener('mousemove', (e) => {
          cursorDot.style.display = window.innerWidth > 768 ? 'block' : 'none';
          cursorDot.style.left = e.clientX + 'px';
          cursorDot.style.top = e.clientY + 'px';
        });
      }
      
      // Theme toggle functionality
      function initTheme() {
        const THEME_KEY = 'uaf-theme';
        function applyTheme(theme){
          document.documentElement.setAttribute('data-theme', theme);
          localStorage.setItem(THEME_KEY, theme);
          themeToggle.innerHTML = theme === 'dark' ? '<i class="fa-solid fa-sun"></i>' : '<i class="fa-solid fa-moon"></i>';
        }
        applyTheme(localStorage.getItem(THEME_KEY) || 'light');
        themeToggle.addEventListener('click', () => {
          const next = (localStorage.getItem(THEME_KEY) || 'light') === 'light' ? 'dark' : 'light';
          applyTheme(next);
        });
      }
      
      // Contact form
      function initContactForm() {
        contactForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          if(!contactForm.checkValidity()){
            e.stopPropagation();
            contactForm.classList.add('was-validated');
            return;
          }
          const data = new FormData(contactForm);
          try{
            const res = await fetch(contactForm.action, { method: 'POST', body: data, headers: {'Accept':'application/json'}});
            if(res.ok){
              contactFormStatus.textContent = "Thanks! We'll get back to you soon.";
              contactFormStatus.className = "text-success";
              contactForm.reset(); contactForm.classList.remove('was-validated');
              showToast('Message sent successfully!', 'success');
            }else{
              contactFormStatus.textContent = "Oops! There was a problem submitting your form.";
              contactFormStatus.className = "text-danger";
              showToast('Failed to send message. Please try again.', 'error');
            }
          }catch{
            contactFormStatus.textContent = "Network error. Try again.";
            contactFormStatus.className = "text-danger";
            showToast('Network error. Please try again.', 'error');
          }
        });
      }
      
      // Add a status message to the log
      function addStatusMessage(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const fullMessage = `[${timestamp}] ${message}`;
        
        // Add to all logs array
        allLogs.push({timestamp, message, type});
        
        const messageEl = document.createElement('div');
        messageEl.className = `status-line status-${type}`;
        messageEl.textContent = fullMessage;
        statusLog.prepend(messageEl);
        
        // Auto-scroll to top
        statusLog.scrollTop = 0;
      }
      
      // Update progress bar
      function updateProgress(percent, status) {
        progressBar.style.width = `${percent}%`;
        progressPercentage.textContent = `${percent}%`;
        if (status) {
          currentStatus.textContent = status;
        }
      }
      
      // Download log
      function downloadLog() {
        addStatusMessage('Preparing log file for download...', 'info');
        
        // Create log content
        let logContent = "UAF CGPA Calculator - Activity Log\n";
        logContent += "============================================\n\n";
        
        allLogs.forEach(log => {
          logContent += `[${log.timestamp}] ${log.message}\n`;
        });
        
        // Create download link
        const blob = new Blob([logContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `cgpa_calculator_log_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
        document.body.appendChild(a);
        a.click();
        
        // Clean up
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
        addStatusMessage('Log file downloaded successfully', 'success');
        showToast('Log file downloaded!', 'success');
      }
      
      // Clear log
      function clearLog() {
        statusLog.innerHTML = '';
        allLogs = [];
        addStatusMessage('Log cleared', 'info');
        showToast('Log cleared', 'info');
      }
      
      // Test connection
      async function testConnection() {
        // Prevent multiple simultaneous test requests
        if (testInProgress) {
          addStatusMessage('Test connection already in progress', 'info');
          return;
        }
        
        testInProgress = true;
        testConnectionBtn.disabled = true;
        
        addStatusMessage('Testing connection to UAF LMS server...', 'info');
        updateProgress(30, 'Testing Connection');
        
        try {
          const response = await fetch(`${API_ENDPOINTS.test}?action=test`, {
            method: 'GET'
          });
          
          // Handle both JSON and HTML responses
          let responseData;
          const contentType = response.headers.get('content-type');
          
          if (contentType && contentType.includes('application/json')) {
            responseData = await response.json();
          } else {
            // If it's HTML, check if the response status is 200
            if (response.status === 200) {
              responseData = {success: true, message: 'Connection to UAF LMS successful'};
            } else {
              responseData = {success: false, message: `UAF LMS returned status code: ${response.status}`};
            }
          }
          
          if (responseData.success) {
            addStatusMessage('Connection test successful - UAF LMS is accessible', 'success');
            showToast('Connection test successful!', 'success');
            updateProgress(100, 'Connection Successful');
          } else {
            addStatusMessage(`Connection test failed: ${responseData.message}`, 'error');
            showToast('Connection test failed!', 'error');
            updateProgress(100, 'Connection Failed');
          }
        } catch (error) {
          addStatusMessage(`Connection test failed: ${error.message}`, 'error');
          showToast('Connection test failed!', 'error');
          updateProgress(100, 'Connection Failed');
        } finally {
          testInProgress = false;
          testConnectionBtn.disabled = false;
          
          // Reset progress after a delay
          setTimeout(() => {
            updateProgress(0, 'Ready');
          }, 2000);
        }
      }
      
      // Process semester name for display (convert Winter 2024-2025 to Winter 2024, Spring 2024-2025 to Spring 2025)
      function processSemesterName(semester) {
        if (!semester) return 'Unknown Semester';
        
        // Handle different semester formats
        if (semester.includes('Winter')) {
          const yearMatch = semester.match(/(\d{4})-(\d{2,4})/);
          if (yearMatch) {
            return `Winter ${yearMatch[1]}`;
          }
        } else if (semester.includes('Spring')) {
          const yearMatch = semester.match(/(\d{4})-(\d{2,4})/);
          if (yearMatch && yearMatch[2].length === 4) {
            return `Spring ${yearMatch[2]`;
          } else if (yearMatch && yearMatch[2].length === 2) {
            return `Spring 20${yearMatch[2]}`;
          }
        } else if (semester.includes('Summer')) {
          // Handle "Summer Semester 2025" -> "Summer 2025"
          const yearMatch = semester.match(/(\d{4})-(\d{2,4})/);
          if (yearMatch) {
            return `Summer ${yearMatch[1]}`;
          }
          // Also handle "Summer Semester 2025" format
          const summerMatch = semester.match(/Summer Semester (\d{4})/);
          if (summerMatch) {
            return `Summer ${summerMatch[1]}`;
          }
        } else if (semester.includes('Fall')) {
          const yearMatch = semester.match(/(\d{4})-(\d{2,4})/);
          if (yearMatch) {
            return `Fall ${yearMatch[1]}`;
          }
        }
        
        // Return original if no pattern matched
        return semester;
      }
      
      // Extract semester order key for internal chronological sorting
      function getSemesterOrderKey(semesterName) {
        if (!semesterName) return '9999-9';
        
        // Extract year and season for chronological ordering
        let year = '';
        let seasonOrder = 9; // Default to last position
        
        // Try to extract year from different patterns
        const yearMatch = semesterName.match(/\b(20\d{2})\b/);
        if (yearMatch) {
          year = yearMatch[1];
        } else {
          // Try 2-digit year format
          const shortYearMatch = semesterName.match(/\b(\d{2})\b/);
          if (shortYearMatch) {
            year = '20' + shortYearMatch[1];
          }
        }
        
        // Determine season order (Winter=1, Spring=2, Summer=3, Fall=4)
        if (semesterName.toLowerCase().includes('winter')) {
          seasonOrder = 1;
        } else if (semesterName.toLowerCase().includes('spring')) {
          seasonOrder = 2;
        } else if (semesterName.toLowerCase().includes('summer')) {
          seasonOrder = 3;
        } else if (semesterName.toLowerCase().includes('fall')) {
          seasonOrder = 4;
        }
        
        // If we couldn't extract year, use a high number to push to end
        if (!year) year = '9999';
        
        return `${year}-${seasonOrder}`;
      }
      
      // Process scraped data to handle re-enrolled courses
      function processScrapedData(data) {
        if (!data || !data.resultData) return null;
        
        const resultData = data.resultData;
        const studentInfo = {
          name: resultData[0]?.StudentName || '',
          registration: resultData[0]?.RegistrationNo || ''
        };
        
        // Group by semester (processed name)
        const semesters = {};
        const courseHistory = {}; // Track course history for re-enrollment detection
        
        // First pass: organize by semester and track course history
        resultData.forEach(course => {
          const originalSemester = course.Semester || 'Unknown Semester';
          const semesterName = processSemesterName(originalSemester);
          const courseCode = course.CourseCode || '';
          
          if (!semesters[semesterName]) {
            semesters[semesterName] = {
              originalName: originalSemester,
              sortKey: getSemesterOrderKey(originalSemester),
              courses: [],
              totalQualityPoints: 0,
              totalCreditHours: 0
            };
          }
          
          // Parse credit hours
          let creditHours = 0;
          const creditHoursStr = course.CreditHours || '0';
          const numbers = creditHoursStr.match(/\d+/g);
          if (numbers && numbers.length > 0) {
            creditHours = parseInt(numbers[0]);
          }
          
          // Parse marks
          let marks = 0;
          try {
            marks = parseFloat(course.Total || '0');
          } catch (e) {
            marks = 0;
          }
          
          // Get grade from scraped data
          const grade = course.Grade || '';
          
          // Calculate quality points based on UAF system
          const qualityPoints = calculateQualityPoints(marks, creditHours);
          
          const courseData = {
            code: courseCode,
            title: course.CourseTitle || '',
            creditHours: creditHours,
            marks: marks,
            qualityPoints: qualityPoints,
            grade: grade,
            originalSemester: originalSemester,
            semesterName: semesterName,
            semesterSortKey: getSemesterOrderKey(originalSemester),
            teacher: course.TeacherName || '',
            mid: course.Mid || '0',
            assignment: course.Assignment || '0',
            final: course.Final || '0',
            practical: course.Practical || '0',
            total: course.Total || '0',
            isExtraEnrolled: false,
            isRepeated: false,
            isDeleted: false,
            originalSemesterForRepeated: null,
            isCustom: false
          };
          
          // Track course history
          if (!courseHistory[courseCode]) {
            courseHistory[courseCode] = [];
          }
          courseHistory[courseCode].push({
            semester: semesterName,
            semesterSortKey: getSemesterOrderKey(originalSemester),
            marks: marks,
            qualityPoints: qualityPoints,
            data: courseData
          });
          
          semesters[semesterName].courses.push(courseData);
        });
        
        // Second pass: identify re-enrolled courses and mark them
        Object.keys(courseHistory).forEach(courseCode => {
          const history = courseHistory[courseCode];
          if (history.length > 1) {
            // Sort by semester order (chronological)
            history.sort((a, b) => a.semesterSortKey.localeCompare(b.semesterSortKey));
            
            // Find the highest marks/quality points (this will be used for CGPA)
            let highest = history[0];
            for (let i = 1; i < history.length; i++) {
              if (history[i].marks > highest.marks) {
                highest = history[i];
              }
            }
            
            // Mark the highest instance as repeated (this gets the "Reptd." label)
            // The course with higher marks should show "Reptd." 
            highest.data.isRepeated = true;
            highest.data.originalSemesterForRepeated = history.find(h => h !== highest)?.semester;
            
            // Mark all other instances as extra enrolled (but don't show "Reptd." on them)
            history.forEach(item => {
              if (item !== highest) {
                item.data.isExtraEnrolled = true;
              }
            });
          }
        });
        
        return {
          studentInfo: studentInfo,
          semesters: semesters,
          courseHistory: courseHistory
        };
      }
      
      // Calculate quality points based on UAF grading system
      function calculateQualityPoints(marks, creditHours) {
        marks = parseFloat(marks);
        creditHours = parseInt(creditHours);

        let qualityPoints = 0;

        if (creditHours === 5) {
          if (marks >= 80) {
            qualityPoints = 20;
          } else if (marks >= 50) {
            qualityPoints = 20 - ((80 - marks) * 0.33333);
          } else if (marks < 50) {
            qualityPoints = 10 - ((50 - marks) * 0.5);
          }
          if (marks < 40) {
            qualityPoints = 0;
          }
        } else if (creditHours === 4) {
          if (marks >= 64) {
            qualityPoints = 16;
          } else if (marks >= 40) {
            qualityPoints = 16 - ((64 - marks) * 0.33333);
          } else if (marks < 40) {
            qualityPoints = 8 - ((40 - marks) * 0.5);
          }
          if (marks < 32) {
            qualityPoints = 0;
          }
        } else if (creditHours === 3) {
          if (marks >= 48) {
            qualityPoints = 12;
          } else if (marks >= 30) {
            qualityPoints = 12 - ((48 - marks) * 0.33333);
          } else if (marks < 30) {
            qualityPoints = 6 - ((30 - marks);
          }
          if (marks < 24) {
            qualityPoints = 0;
          }
        } else if (creditHours === 2) {
          if (marks >= 32) {
            qualityPoints = 8;
          } else if (marks >= 20) {
            qualityPoints = 8 - ((32 - marks) * 0.33333);
          } else if (marks < 20) {
            qualityPoints = 4 - ((20 - marks) * 0.5);
          }
          if (marks < 16) {
            qualityPoints = 0;
          }
        } else if (creditHours === 1) {
          if (marks >= 16) {
            qualityPoints = 4;
          } else if (marks >= 10) {
            qualityPoints = 4 - ((16 - marks) * 0.33333);
          } else if (marks < 10) {
            qualityPoints = 2 - ((10 - marks) * 0.5);
          }
          if (marks < 8) {
            qualityPoints = 0;
          }
        }

        return parseFloat(qualityPoints.toFixed(2));
      }
      
      // Calculate CGPA from processed data
      function calculateCGPA(processedData) {
        if (!processedData) return null;
        
        let totalQualityPoints = 0;
        let totalCreditHours = 0;
        let totalMarksObtained = 0;
        let totalMaxMarks = 0;
        
        // Calculate for each semester (in display order, not chronological)
        Object.keys(processedData.semesters).forEach(semesterName => {
          const semester = processedData.semesters[semesterName];
          semester.totalQualityPoints = 0;
          semester.totalCreditHours = 0;
          semester.totalMarksObtained = 0;
          semester.totalMaxMarks = 0;
          
          semester.courses.forEach(course => {
            // Only count non-extra enrolled and non-deleted courses for CGPA
            if (!course.isExtraEnrolled && !course.isDeleted) {
              semester.totalQualityPoints += course.qualityPoints;
              semester.totalCreditHours += course.creditHours;
              semester.totalMarksObtained += course.marks;
              
              // Calculate max marks based on credit hours
              let maxMarks = 0;
              if (course.creditHours === 5) maxMarks = 100;
              else if (course.creditHours === 4) maxMarks = 80;
              else if (course.creditHours === 3) maxMarks = 60;
              else if (course.creditHours === 2) maxMarks = 40;
              else if (course.creditHours === 1) maxMarks = 20;
              
              semester.totalMaxMarks += maxMarks;
              totalMaxMarks += maxMarks;
              
              totalQualityPoints += course.qualityPoints;
              totalCreditHours += course.creditHours;
              totalMarksObtained += course.marks;
            }
          });
          
          // Calculate semester GPA
          if (semester.totalCreditHours > 0) {
            semester.gpa = parseFloat((semester.totalQualityPoints / semester.totalCreditHours).toFixed(4));
            semester.percentage = parseFloat((semester.totalMarksObtained / semester.totalMaxMarks * 100).toFixed(2));
          } else {
            semester.gpa = 0;
            semester.percentage = 0;
          }
        });
        
        // Calculate overall CGPA
        const cgpa = totalCreditHours > 0 ? parseFloat((totalQualityPoints / totalCreditHours).toFixed(4)) : 0;
        const percentage = totalMaxMarks > 0 ? parseFloat((totalMarksObtained / totalMaxMarks * 100).toFixed(2)) : 0;
        
        return {
          cgpa: cgpa,
          percentage: percentage,
          totalQualityPoints: totalQualityPoints,
          totalCreditHours: totalCreditHours,
          totalMarksObtained: totalMarksObtained,
          totalMaxMarks: totalMaxMarks
        };
      }
      
      // Display CGPA results
      function displayCGPAResults(processedData, cgpaData) {
        // Update student info
        studentName.textContent = processedData.studentInfo.name;
        studentReg.textContent = processedData.studentInfo.registration;
        
        // Update overall CGPA
        totalCgpa.textContent = cgpaData.cgpa;
        totalPercentage.textContent = `${cgpaData.percentage}%`;
        
        // Clear previous semester results
        semesterResults.innerHTML = '';
        
        // Create semester cards in their original order (not chronological)
        Object.keys(processedData.semesters).forEach(semesterName => {
          const semester = processedData.semesters[semesterName];
          
          const semesterCard = document.createElement('div');
          semesterCard.className = 'semester-card';
          semesterCard.dataset.semester = semesterName;
          
          semesterCard.innerHTML = `
            <div class="d-flex justify-content-between align-items-start mb-3">
              <h5 class="mb-0">
                <i class="fa-solid fa-book-open me-2 text-blue-600"></i>
                ${semesterName}
              </h5>
              <div class="d-flex gap-2">
                <button class="btn btn-sm btn-primary add-course-btn" data-semester="${semesterName}" title="Add custom course">
                  <i class="fa-solid fa-plus"></i> Add Course
                </button>
                <i class="fa-solid fa-trash delete-semester" title="Delete this semester"></i>
              </div>
            </div>
            <div class="text-right mb-3">
              <p class="mb-0 text-body-secondary small">GPA:</p>
              <p class="mb-0 h4 fw-bold text-blue-600">${semester.gpa || 0}</p>
              <p class="mb-0 text-body-secondary small">${semester.percentage || 0}%</p>
            </div>
            <div class="table-responsive">
              <table class="course-table">
                <thead>
                  <tr>
                    <th>Course</th>
                    <th>Hrs</th>
                    <th>Marks</th>
                    <th>Grade</th>
                    <th>GP</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  ${semester.courses.map(course => `
                    <tr class="${course.isExtraEnrolled ? 'table-warning' : ''} ${course.isDeleted ? 'table-danger text-decoration-line-through' : ''}">
                      <td>
                        <div class="d-flex align-items-center">
                          <span class="fw-medium course-code clickable-info" data-course='${JSON.stringify(course).replace(/'/g, "&#39;")}'>${course.code}</span>
                          ${course.isRepeated ? '<span class="extra-enrolled clickable-repeated" data-course=\'' + JSON.stringify(course).replace(/'/g, "&#39;") + '\'>Reptd.</span>' : ''}
                          <i class="fa-solid fa-info-circle ms-2 clickable-info small" data-course='${JSON.stringify(course).replace(/'/g, "&#39;")}' title="${course.title}"></i>
                        </div>
                      </td>
                      <td>${course.creditHours}</td>
                      <td>${course.marks}</td>
                      <td>
                        <span class="grade-badge grade-${course.grade}">${course.grade}</span>
                      </td>
                      <td class="fw-medium text-blue-600">${course.qualityPoints.toFixed(2)}</td>
                      <td class="course-actions">
                        ${course.isDeleted ? 
                          `<i class="fa-solid fa-rotate-left restore-course" data-course='${JSON.stringify(course).replace(/'/g, "&#39;")}' data-semester="${semesterName}" title="Restore this course"></i>` : 
                          `<i class="fa-solid fa-trash delete-course" data-course='${JSON.stringify(course).replace(/'/g, "&#39;")}' data-semester="${semesterName}" title="Delete this course"></i>`
                        }
                      </td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            </div>
          `;
          
          semesterResults.appendChild(semesterCard);
        });
        
        // Add event listeners for course details and delete buttons
        document.querySelectorAll('.clickable-info').forEach(el => {
          el.addEventListener('click', function() {
            const courseData = JSON.parse(this.dataset.course.replace(/&#39;/g, "'"));
            showCourseDetails(courseData);
          });
        });
        
        // Add event listeners for repeated course labels
        document.querySelectorAll('.clickable-repeated').forEach(el => {
          el.addEventListener('click', function() {
            const courseData = JSON.parse(this.dataset.course.replace(/&#39;/g, "'"));
            if (courseData.originalSemesterForRepeated) {
              // Scroll to the original semester
              const semesterElement = document.querySelector(`.semester-card[data-semester="${courseData.originalSemesterForRepeated}"]`);
              if (semesterElement) {
                semesterElement.scrollIntoView({ behavior: 'smooth' });
                // Add highlight effect
                semesterElement.style.transition = 'all 0.5s ease';
                semesterElement.style.boxShadow = '0 0 20px rgba(122, 106, 216, 0.5)';
                setTimeout(() => {
                  semesterElement.style.boxShadow = '';
                }, 2000);
              }
            }
          });
        });
        
        // Add event listeners for add course buttons
        document.querySelectorAll('.add-course-btn').forEach(btn => {
          btn.addEventListener('click', function() {
            const semesterName = this.dataset.semester;
            document.getElementById('customCourseSemester').value = semesterName;
            bootstrap.Modal.getOrCreateInstance(document.getElementById('addCourseModal')).show();
          });
        });
        
        document.querySelectorAll('.delete-semester').forEach(btn => {
          btn.addEventListener('click', function() {
            const semesterCard = this.closest('.semester-card');
            const semesterName = semesterCard.dataset.semester;
            deleteSemester(semesterName);
          });
        });
        
        document.querySelectorAll('.delete-course').forEach(btn => {
          btn.addEventListener('click', function() {
            const courseData = JSON.parse(this.dataset.course.replace(/&#39;/g, "'"));
            const semesterName = this.dataset.semester;
            deleteCourse(courseData, semesterName);
          });
        });
        
        document.querySelectorAll('.restore-course').forEach(btn => {
          btn.addEventListener('click', function() {
            const courseData = JSON.parse(this.dataset.course.replace(/&#39;/g, "'"));
            const semesterName = this.dataset.semester;
            restoreCourse(courseData, semesterName);
          });
        });
        
        // Show result container and calculate button
        resultContainer.style.display = 'block';
        gpaResultCard.style.display = 'block';
        calculateCgpaBtn.style.display = 'block';
      }
      
      // Show course details in modal
      function showCourseDetails(course) {
        document.getElementById('courseDetailsModalTitle').textContent = `${course.code} - ${course.title}`;
        
        const modalBody = document.getElementById('courseDetailsModalBody');
        
        let repeatedInfoHtml = '';
        if (course.isRepeated && course.originalSemesterForRepeated) {
          repeatedInfoHtml = `
            <div class="row mt-3">
              <div class="col-12">
                <div class="alert alert-warning">
                  <i class="fa-solid fa-exclamation-triangle me-2"></i>
                  <p class="mb-1">This is a repeated course. The marks and quality points are considered from this semester instead of the original enrollment in <strong class="clickable-semester" data-semester="${course.originalSemesterForRepeated}" style="cursor: pointer; text-decoration: underline;">${course.originalSemesterForRepeated}</strong></p>
                  <p class="mb-0 small">Click on the semester name to view the original enrollment</p>
                </div>
              </div>
            </div>
          `;
        }
        
        modalBody.innerHTML = `
          <div class="row">
            <div class="col-md-6">
              <p><strong>Teacher:</strong> ${course.teacher}</p>
              <p><strong>Credit Hours:</strong> ${course.creditHours}</p>
              <p><strong>Semester:</strong> ${course.semesterName}</p>
              ${course.isCustom ? '<p><strong>Type:</strong> Custom Course</p>' : ''}
            </div>
            <div class="col-md-6">
              <p><strong>Mid Term:</strong> ${course.mid}</p>
              <p><strong>Assignment:</strong> ${course.assignment}</p>
              <p><strong>Final Term:</strong> ${course.final}</p>
              ${course.practical ? `<p><strong>Practical:</strong> ${course.practical}</p>` : ''}
            </div>
          </div>
          <div class="row mt-3">
            <div class="col-12">
              <div class="alert alert-info">
                <p class="mb-1"><strong>Total Marks:</strong> ${course.total}</p>
                <p class="mb-1"><strong>Grade:</strong> <span class="grade-badge grade-${course.grade}">${course.grade}</span></p>
                <p class="mb-0"><strong>Quality Points:</strong> ${course.qualityPoints.toFixed(2)}</p>
              </div>
            </div>
          </div>
          ${repeatedInfoHtml}
        `;
        
        // Add event listener for semester link if it exists
        const semesterLink = modalBody.querySelector('.clickable-semester');
        if (semesterLink) {
          semesterLink.addEventListener('click', function() {
            const semesterName = this.dataset.semester;
            courseDetailsModal.hide();
            
            // Scroll to the semester
            const semesterElement = document.querySelector(`.semester-card[data-semester="${semesterName}"]`);
            if (semesterElement) {
              semesterElement.scrollIntoView({ behavior: 'smooth' });
              // Add highlight effect
              semesterElement.style.transition = 'all 0.5s ease';
              semesterElement.style.boxShadow = '0 0 20px rgba(122, 106, 216, 0.5)';
              setTimeout(() => {
                semesterElement.style.boxShadow = '';
              }, 2000);
            }
          });
        }
        
        courseDetailsModal.show();
      }
      
      // Delete a semester
      function deleteSemester(semesterName) {
        if (!processedData || !processedData.semesters[semesterName]) return;
        
        // Remove semester from processed data
        delete processedData.semesters[semesterName];
        
        // Recalculate CGPA
        const cgpaData = calculateCGPA(processedData);
        
        // Update display
        displayCGPAResults(processedData, cgpaData);
        
        addStatusMessage(`Deleted semester: ${semesterName}`, 'info');
        showToast(`Semester ${semesterName} deleted`, 'info');
      }
      
      // Delete a course
      function deleteCourse(course, semesterName) {
        if (!processedData || !processedData.semesters[semesterName]) return;
        
        // Find the course index
        const semester = processedData.semesters[semesterName];
        const courseIndex = semester.courses.findIndex(c => c.code === course.code && c.marks === course.marks);
        
        if (courseIndex === -1) return;
        
        // Mark course as deleted
        semester.courses[courseIndex].isDeleted = true;
        
        // If this was the best instance of a repeated course, find the next best one
        if (course.isRepeated) {
          // Find all instances of this course
          const courseCode = course.code;
          const allInstances = [];
          
          // Collect all instances of this course
          Object.keys(processedData.semesters).forEach(sem => {
            processedData.semesters[sem].courses.forEach(c => {
              if (c.code === courseCode && !c.isDeleted) {
                allInstances.push({
                  semester: sem,
                  marks: c.marks,
                  qualityPoints: c.qualityPoints,
                  data: c
                });
              }
            });
          });
          
          // If there are other instances, find the best one and update its status
          if (allInstances.length > 0) {
            // Sort by marks (highest first)
            allInstances.sort((a, b) => b.marks - a.marks);
            const bestInstance = allInstances[0];
            
            // Mark the best instance as repeated
            bestInstance.data.isRepeated = true;
            
            // Update all other instances to point to this best instance
            allInstances.forEach((instance, index) => {
              if (index > 0) {
                instance.data.isExtraEnrolled = true;
                instance.data.originalSemesterForRepeated = bestInstance.semester;
              }
            });
          }
        }
        
        // Recalculate CGPA
        const cgpaData = calculateCGPA(processedData);
        
        // Update display
        displayCGPAResults(processedData, cgpaData);
        
        addStatusMessage(`Deleted course: ${course.code} from ${semesterName}`, 'info');
        showToast(`Course ${course.code} deleted`, 'info');
      }
      
      // Restore a course
      function restoreCourse(course, semesterName) {
        if (!processedData || !processedData.semesters[semesterName]) return;
        
        // Find the course index
        const semester = processedData.semesters[semesterName];
        const courseIndex = semester.courses.findIndex(c => c.code === course.code && c.marks === course.marks);
        
        if (courseIndex === -1) return;
        
        // Mark course as not deleted
        semester.courses[courseIndex].isDeleted = false;
        
        // If this is a repeated course, we need to determine which instance should be used for CGPA
        if (course.isRepeated) {
          // Find all instances of this course
          const courseCode = course.code;
          const allInstances = [];
          
          // Collect all instances of this course
          Object.keys(processedData.semesters).forEach(sem => {
            processedData.semesters[sem].courses.forEach(c => {
              if (c.code === courseCode && !c.isDeleted) {
                allInstances.push({
                  semester: sem,
                  marks: c.marks,
                  qualityPoints: c.qualityPoints,
                  data: c
                });
              }
            });
          });
          
          // If there are multiple instances, find the best one
          if (allInstances.length > 1) {
            // Sort by marks (highest first)
            allInstances.sort((a, b) => b.marks - a.marks);
            const bestInstance = allInstances[0];
            
            // Mark the best instance as repeated
            bestInstance.data.isRepeated = true;
            
            // Update all other instances to point to this best instance
            allInstances.forEach((instance, index) => {
              if (index > 0) {
                instance.data.isExtraEnrolled = true;
                instance.data.originalSemesterForRepeated = bestInstance.semester;
              } else {
                instance.data.isExtraEnrolled = false;
              }
            });
          }
        }
        
        // Recalculate CGPA
        const cgpaData = calculateCGPA(processedData);
        
        // Update display
        displayCGPAResults(processedData, cgpaData);
        
        addStatusMessage(`Restored course: ${course.code} in ${semesterName}`, 'info');
        showToast(`Course ${course.code} restored`, 'success');
      }
      
      // Recalculate CGPA when button is clicked
      function recalculateCGPA() {
        if (!processedData) return;
        
        const cgpaData = calculateCGPA(processedData);
        
        // Update overall CGPA
        totalCgpa.textContent = cgpaData.cgpa;
        totalPercentage.textContent = `${cgpaData.percentage}%`;
        
        showToast('CGPA recalculated successfully!', 'success');
        addStatusMessage('CGPA recalculated based on current semesters', 'info');
      }
      
      // Fetch result from UAF LMS
      async function fetchResult() {
        const regNum = registrationNumber.value.trim();
        
        if (!regNum) {
          showToast('Please enter a registration number', 'error');
          return;
        }
        
        // Show loading animation
        loading.style.display = 'block';
        resultContainer.style.display = 'none';
        calculateCgpaBtn.style.display = 'none';
        updateProgress(10, 'Starting Fetch');
        addStatusMessage(`Fetching result for registration number: ${regNum}`, 'info');
        
        try {
          const response = await fetch(`${API_ENDPOINTS.scrape}?action=scrape_single&registrationNumber=${encodeURIComponent(regNum)}`, {
            method: 'GET'
          });
          
          updateProgress(50, 'Processing Data');
          
          const data = await response.json();
          
          if (data.success) {
            scrapedData = data;
            addStatusMessage('Result fetched successfully', 'success');
            updateProgress(70, 'Processing Data');
            
            // Process the scraped data
            processedData = processScrapedData(data);
            
            if (processedData) {
              // Calculate CGPA
              const cgpaData = calculateCGPA(processedData);
              
              // Display the result
              displayCGPAResults(processedData, cgpaData);
              
              addStatusMessage('CGPA calculated successfully', 'success');
              updateProgress(100, 'Fetch Complete');
              showToast('Result fetched successfully!', 'success');
            } else {
              addStatusMessage('Error processing result data', 'error');
              showToast('Error processing result data', 'error');
              updateProgress(100, 'Error');
            }
          } else {
            addStatusMessage(`Error: ${data.message}`, 'error');
            showToast(data.message, 'error');
            updateProgress(100, 'Error');
          }
        } catch (error) {
          addStatusMessage(`Error fetching result: ${error.message}`, 'error');
          showToast('Error fetching result', 'error');
          updateProgress(100, 'Error');
        } finally {
          loading.style.display = 'none';
          
          // Reset progress after a delay
          setTimeout(() => {
            updateProgress(0, 'Ready');
          }, 2000);
        }
      }
      
      // Event listeners
      resultForm.addEventListener('submit', function(e) {
        e.preventDefault();
        fetchResult();
      });
      
      testConnectionBtn.addEventListener('click', testConnection);
      
      downloadLogBtn.addEventListener('click', downloadLog);
      
      clearLogBtn.addEventListener('click', clearLog);
      
      calculateCgpaBtn.addEventListener('click', recalculateCGPA);
      
      // Initialize the application
      init();
    });
  </script>
